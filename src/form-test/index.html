<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title>form test</title>
  </head>
  <body>
    <div id="feed">
    </div>
    <script type="text/javascript">
      (async function(){

        const CRLF = '\r\n'

        const el = document.querySelector('#feed')
        const res = await fetch('/posts')
        console.log("res:", res)

        const contentType = res.headers.get('content-type')
        const m = contentType.match(/multipart\/form-data; boundary=(.+)$/)
        const boundary = m[1]
        // console.log("boundary:", boundary)
        const bytesBoundary = new TextEncoder('ascii').encode(CRLF+'--'+boundary+CRLF)
        const endBytes = new TextEncoder('ascii').encode(CRLF+'--'+boundary+'--')
        const doubleBreak = new TextEncoder('ascii').encode(CRLF+CRLF)

        // keep a list of http responses?
        const responses = []

        function boundaryAtIndex(array, bytesBoundary, idx) {
          for (let i=0; i<bytesBoundary.length; i++) {
            if (array[idx+i] !== bytesBoundary[i]) return false
          }
          return true
        }

        function getBoundaryIndexes(array, bytesBoundary) {
          const indexes = []
          for (let i=0; i<array.length-bytesBoundary.length; i++) {
            // console.log("looking for boundary at", i)
            if (boundaryAtIndex(array, bytesBoundary, i)) indexes.push(i)
          }
          return indexes
        }

        function parseHeaders(headers) {
          const h = {}
          for (const line of headers.split(CRLF)) {
            const idx = line.indexOf(': ')
            const key = line.slice(0, idx)
            const val = line.slice(idx+2, line.length)
            h[key.toLowerCase()] = val
          }
          return h
        }

        const reader = res.body.getReader()
        let finished = false
        while (!finished) {
          const { done, value } = await reader.read()
          console.log("value:", value)
          // console.log("as text", new TextDecoder("utf-8").decode(value))
          if (value) {
            const boundaryIndexes = getBoundaryIndexes(value, bytesBoundary)
            const endBoundary = getBoundaryIndexes(value, endBytes)[0]
            console.log("boundaries found at", boundaryIndexes, "end at", endBoundary)
            boundaryIndexes.push(endBoundary)
            // split at all boundaries
            do {
              const entry = value.slice(boundaryIndexes.shift()+bytesBoundary.length, boundaryIndexes[0]-CRLF.length)
              if (entry.length === 0) {
                console.log("end of body")
              } else {
                const firstLineBreak = getBoundaryIndexes(entry, doubleBreak)[0]
                const headers = parseHeaders(new TextDecoder("utf-8").decode(entry.slice(0, firstLineBreak)))
                console.log("headers:", headers)
                const type = headers['content-type']
                const body = entry.slice(firstLineBreak+doubleBreak.length, entry.length)
                if (type.includes('text')) {
                  const text = new TextDecoder("utf-8").decode(body)
                  console.log("body text:", JSON.stringify(text))
                  responses.push(Object.assign(headers, { text }))
                } else {
                  const url = URL.createObjectURL(new Blob([body]))
                }
              }

            } while (boundaryIndexes[0])

          }
          finished = done
        }

        for (const p of responses) {
          const type = p['content-type']
          const date = p['post-time']
          if (type.includes('text')) {
            el.innerHTML += `<div>${p.text} - ${date}</div>`
          } else if (type.includes('image')) {
            el.innerHTML += `<div><img style="max-width:200px" src="${p.url}"></div>`
          }
        }


        //// this works, but no way to get the per-entry headers

        // const form = await res.formData()
        // console.log("form:", form)
        // for (const [name, f] of form) {
        //   console.log("form entry:", f)
        //   if (f.type.includes('text')) {
        //     const text = await f.text()
        //     el.innerHTML += `<div>${text}</div>`
        //   } else if (f.type.includes('image')) {
        //     const url = URL.createObjectURL(f)
        //     el.innerHTML += `<div><img style="max-width:200px" src="${url}"></div>`
        //   }
        // }
      })()
    </script>
  </body>
</html>
